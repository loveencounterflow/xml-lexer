{
  "version": 3,
  "file": "main.js",
  "sourceRoot": "..",
  "sources": [
    "src/main.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "'use strict'\n\n\nEventEmitter = require('eventemitter3')\n{ isa\n  validate\n  type_of }               = ( new ( require 'intertype' ).Intertype() ).export()\n\nnoop = ->\n\nState = {\n  data:                   'state-data'\n  cdata:                  'state-cdata'\n  tagBegin:               'state-tag-begin'\n  tagName:                'state-tag-name'\n  tagEnd:                 'state-tag-end'\n  attributeNameStart:     'state-attribute-name-start'\n  attributeName:          'state-attribute-name'\n  attributeNameEnd:       'state-attribute-name-end'\n  attributeValueBegin:    'state-attribute-value-begin'\n  attributeValue:         'state-attribute-value'\n  }\n\nAction = {\n  lt:                     'action-lt'\n  gt:                     'action-gt'\n  space:                  'action-space'\n  equal:                  'action-equal'\n  quote:                  'action-quote'\n  slash:                  'action-slash'\n  chr:                    'action-chr'\n  error:                  'action-error'\n  }\n\nType = {\n  text:                   'text'\n  openTag:                'open-tag'\n  closeTag:               'close-tag'\n  attributeName:          'attribute-name'\n  attributeValue:         'attribute-value'\n  }\n\ncharToAction = {\n  ' ':                    Action.space\n  '\\t':                   Action.space\n  '\\n':                   Action.space\n  '\\r':                   Action.space\n  '<':                    Action.lt\n  '>':                    Action.gt\n  '\"':                    Action.quote\n  \"'\":                    Action.quote\n  '=':                    Action.equal\n  '/':                    Action.slash\n  }\n\n#-----------------------------------------------------------------------------------------------------------\naction_from_chr = ( chr ) => charToAction[ chr ] ? Action.chr\n\n#-----------------------------------------------------------------------------------------------------------\ncreate = ( settings, handler ) ->\n  switch arity = arguments.length\n    when 0 then null\n    when 1 then [ settings, handler, ] = [ null, settings, ]\n    when 2 then null\n    else throw new Error \"^55563^ expected 1 or 2 arguments, got #{arity}\"\n  [ settings, handler, ] = [ handler, null, ] unless isa.function handler\n  ### TAINT validate.xmllexer_settings settings ? {} ###\n  ### TAINT validate.function handler ###\n  settings          = { { debug: false, }..., settings..., }\n  lexer             = new EventEmitter()\n  state             = State.data\n  data              = ''\n  tagName           = ''\n  attrName          = ''\n  attrValue         = ''\n  isClosing         = false\n  openingQuote      = ''\n\n  #---------------------------------------------------------------------------------------------------------\n  step = ( chr ) =>\n    if settings.debug then console.log state, chr\n    actions = lexer.stateMachine[ state ]\n    action  = actions[ action_from_chr chr ] ? actions[ Action.error ] ? actions[ Action.chr ]\n    action chr\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  lexer.write = ( str ) =>\n    len = str.length\n    for i in [ 0 ... len ]\n      step str[ i ]\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  emit = ( type, value ) =>\n    # tags like: '?xml', '!DOCTYPE', comments\n    if ( first_chr = tagName[ 0 ] ) in '?!'\n      return null\n    event = { type, value }\n    console.log 'emit:', event if settings.debug\n    if handler? then  handler event\n    else              lexer.emit 'data', event\n\n  ```\n  lexer.stateMachine = {\n    [State.data]: {\n      [Action.lt]: () => {\n        if (data.trim()) {\n          emit(Type.text, data);\n        }\n        tagName = '';\n        isClosing = false;\n        state = State.tagBegin;\n      },\n      [Action.chr]: (chr) => {\n        data += chr;\n      },\n    },\n    [State.cdata]: {\n      [Action.chr]: (chr) => {\n        data += chr;\n        if (data.substr(-3) === ']]>') {\n          emit(Type.text, data.slice(0, -3));\n          data = '';\n          state = State.data;\n        }\n      },\n    },\n    [State.tagBegin]: {\n      [Action.space]: noop,\n      [Action.chr]: (chr) => {\n        tagName = chr;\n        state = State.tagName;\n      },\n      [Action.slash]: () => {\n        tagName = '';\n        isClosing = true;\n      },\n    },\n    [State.tagName]: {\n      [Action.space]: () => {\n        if (isClosing) {\n          state = State.tagEnd;\n        } else {\n          state = State.attributeNameStart;\n          emit(Type.openTag, tagName);\n        }\n      },\n      [Action.gt]: () => {\n        if (isClosing) {\n          emit(Type.closeTag, tagName);\n        } else {\n          emit(Type.openTag, tagName);\n        }\n        data = '';\n        state = State.data;\n      },\n      [Action.slash]: () => {\n        state = State.tagEnd;\n        emit(Type.openTag, tagName);\n      },\n      [Action.chr]: (chr) => {\n        tagName += chr;\n        if (tagName === '![CDATA[') {\n          state = State.cdata;\n          data = '';\n          tagName = '';\n        }\n      },\n    },\n    [State.tagEnd]: {\n      [Action.gt]: () => {\n        emit(Type.closeTag, tagName);\n        data = '';\n        state = State.data;\n      },\n      [Action.chr]: noop,\n    },\n    [State.attributeNameStart]: {\n      [Action.chr]: (chr) => {\n        attrName = chr;\n        state = State.attributeName;\n      },\n      [Action.gt]: () => {\n        data = '';\n        state = State.data;\n      },\n      [Action.space]: noop,\n      [Action.slash]: () => {\n        isClosing = true;\n        state = State.tagEnd;\n      },\n    },\n    [State.attributeName]: {\n      [Action.space]: () => {\n        state = State.attributeNameEnd;\n      },\n      [Action.equal]: () => {\n        emit(Type.attributeName, attrName);\n        state = State.attributeValueBegin;\n      },\n      [Action.gt]: () => {\n        attrValue = '';\n        emit(Type.attributeName, attrName);\n        emit(Type.attributeValue, attrValue);\n        data = '';\n        state = State.data;\n      },\n      [Action.slash]: () => {\n        isClosing = true;\n        attrValue = '';\n        emit(Type.attributeName, attrName);\n        emit(Type.attributeValue, attrValue);\n        state = State.tagEnd;\n      },\n      [Action.chr]: (chr) => {\n        attrName += chr;\n      },\n    },\n    [State.attributeNameEnd]: {\n      [Action.space]: noop,\n      [Action.equal]: () => {\n        emit(Type.attributeName, attrName);\n        state = State.attributeValueBegin;\n      },\n      [Action.gt]: () => {\n        attrValue = '';\n        emit(Type.attributeName, attrName);\n        emit(Type.attributeValue, attrValue);\n        data = '';\n        state = State.data;\n      },\n      [Action.chr]: (chr) => {\n        attrValue = '';\n        emit(Type.attributeName, attrName);\n        emit(Type.attributeValue, attrValue);\n        attrName = chr;\n        state = State.attributeName;\n      },\n    },\n    [State.attributeValueBegin]: {\n      [Action.space]: noop,\n      [Action.quote]: (chr) => {\n        openingQuote = chr;\n        attrValue = '';\n        state = State.attributeValue;\n      },\n      [Action.gt]: () => {\n        attrValue = '';\n        emit(Type.attributeValue, attrValue);\n        data = '';\n        state = State.data;\n      },\n      [Action.chr]: (chr) => {\n        openingQuote = '';\n        attrValue = chr;\n        state = State.attributeValue;\n      },\n    },\n    [State.attributeValue]: {\n      [Action.space]: (chr) => {\n        if (openingQuote) {\n          attrValue += chr;\n        } else {\n          emit(Type.attributeValue, attrValue);\n          state = State.attributeNameStart;\n        }\n      },\n      [Action.quote]: (chr) => {\n        if (openingQuote === chr) {\n          emit(Type.attributeValue, attrValue);\n          state = State.attributeNameStart;\n        } else {\n          attrValue += chr;\n        }\n      },\n      [Action.gt]: (chr) => {\n        if (openingQuote) {\n          attrValue += chr;\n        } else {\n          emit(Type.attributeValue, attrValue);\n          data = '';\n          state = State.data;\n        }\n      },\n      [Action.slash]: (chr) => {\n        if (openingQuote) {\n          attrValue += chr;\n        } else {\n          emit(Type.attributeValue, attrValue);\n          isClosing = true;\n          state = State.tagEnd;\n        }\n      },\n      [Action.chr]: (chr) => {\n        attrValue += chr;\n      },\n    },\n  };\n\n\n  ```\n  return lexer\n\n\nmodule.exports = { State, Action, Type, create, }\n\n\n\n\n"
  ]
}